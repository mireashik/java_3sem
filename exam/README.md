Практики: https://north-baron-8f3.notion.site/5874554c3d654964983d8d99de38df7b
<br>
https://github.com/fl-3650/JavaExamPractice

https://gregggreggreg.github.io/java_cource/topic_1_01.html

### 1. Парадигма объектно-ориентированного программирование. Основные принципы ООП и их реализация в языке программирования Java и С++
### Наследование
Наследование — механизм, который позволяет описать новый класс на основе существующего (родительского). При этом свойства и функциональность родительского класса заимствуются новым классом.

### Абстракция
Абстракция означает выделение главных, наиболее значимых характеристик предмета и наоборот — отбрасывание второстепенных, незначительных.

### Инкапсуляция
С ним мы уже сталкивались. Инкапсуляция в Java означает ограничение доступа к данным и возможностям их изменения.

Как видишь, в его основе лежит слово «капсула». В эту «капсулу» мы прячем какие-то важные для нас данные, которые не хотим, чтобы кто-то менял.

Очевидные примеры инкапсуляции, с которыми ты уже работал, — это модификаторы доступа (private, public и т.д.), а также геттеры-сеттеры.

### Полиморфизм
Полиморфизм — это возможность работать с несколькими типами так, будто это один и тот же тип. При этом поведение объектов будет разным в зависимости от типа, к которому они принадлежат.

Полиморфизм – это способность программы идентично использовать объекты с одинаковым интерфейсом без информации о конкретном типе этого объекта.

### 2. Организация программы на Java. Основные структурные единицы. Процесс интерпретации и компиляции. Роль JVM
![image](https://github.com/mireashik/java_3sem/assets/49165758/ed58c265-1269-44b1-9a91-e2c75021f78d)

![image](https://github.com/mireashik/java_3sem/assets/49165758/0f190b5b-063b-4184-a856-c0fc45021e9f)

Программа на языке Java – это обычный текстовый файл с расширением java. Результат работы **компилятора** сохраняется в одинаковых файлах с расширением (точка). **сlass**.

Это значит, что программы, написанные на языке Java, можно выполнять на любой платформе, где установлена специальная исполняющая система Java. Такая система называется Java Virtual Machine (JVM). Для того, чтобы перевести программу из исходного кода в код, понятный JVM, нужно её скомпилировать. Код, понятный JVM называется **байт-кодом** и содержит набор инструкций, которые в дальнейшем будет исполнять виртуальная машина.

После того, как программа была скомпилирована в байт-код, она может быть выполнена с помощью виртуальной машины.

**Компиляция** — трансляция программы, составленной на исходном языке высокого уровня, в эквивалентную программу на низкоуровневом языке, близком машинному коду.
<br>
преобразование исходного текста программы в машинный код.

**Интерпретация** — пооператорный (покомандный, построчный) анализ, обработка и тут же выполнение исходной программы или запроса (в отличие от компиляции, при которой программа транслируется без её выполнения).
<br>
непосредственное исполнение исходного текста программы.

Язык Java обладает как компилятором (javac), так и интерпретатором, в роли которого выступает виртуальная машина, которая построчно преобразует байт-код в машинный код и тут же его исполняет. Таким образом, когда мы запускаем скомпилированную программу, **виртуальная машина начинает её интерпретацию, то есть построчное преобразование байт-кода** в машинный код, а так же его исполнение.

### 3. Структурирование Java приложения, пакеты. Уровни доступа и видимости
- private
- protected
- default (package visible)
- public

**Private** — наиболее строгий модификатор доступа. Он ограничивает видимость данных и методов пределами одного класса.

Собственно, ограничение доступа к полям и реализация геттеров-сеттеров — самый распространенный пример использования **private** в реальной работе.

----

Поля и методы, обозначенные модификатором доступа protected, будут видны:
- в пределах всех классов, находящихся в том же **пакете**, что и наш;
- в пределах всех классов-**наследников** нашего класса.

Представь, что у нас есть абстрактный класс AbstractSecretAgent, обозначающий **секретного агента** какой-то спецслужбы, а также пакет top_secret, в котором лежит этот класс и его наследники. От него наследуются конкретные классы — FBISecretAgent, MI6SecretAgent, MossadSecretAgent и т.п.

-----

Дальше у нас по списку идет модификатор **default** или, как его еще называют, **package visible**. Он не обозначается ключевым словом, поскольку установлен в Java по умолчанию для всех полей и методов.

В Java существует четыре модификатора доступа, одним из которых является **package private** (его еще называют default или no modifier). У него нет своего ключевого слова. Данный вид доступа применяется по умолчанию, когда никакой из модификаторов не указан явно.

Если метод (или переменная) не помечены никаким модификатором, считается, что они помечены «модификатором по умолчанию». Переменные или методы с таким модификатором (т.е. вообще без какого-нибудь) видны всем классам пакета, в котором они объявлены. И только им. В пакете можно определить классы, которые будут недоступны за его пределами.

-----

public создан для того, чтобы отдавать что-то пользователям. Например, **интерфейс** твоей программы. Части кода, помеченные модификатором public, предназначаются для конечного пользователя.

Если к полю, методу или классу применен модификатор public, к ним можно обращаться **из любого места программы**. То есть public-сущности доступны любым другим классам **как в текущем пакете, так и за его пределами**. Данное положение не отменяет необходимости импорта пакета.

### Пакеты
Пакет (Package) в Java — это способ объединить группу классов, интерфейсов и подпакетов. С помощью пакетов создаются группы связанных классов, интерфейсов, перечислений и так далее.

Подпакеты — это пакеты, находящиеся в другом пакете. Они не импортируются по умолчанию, но при необходимости их можно импортировать вручную. Спецификация доступа не предоставляется отдельным членам подпакета, они рассматриваются как разные пакеты.

java.lang — по умолчанию поставляется в комплекте с Java.
<br>
java.io — содержит классы, методы и другие элементы, связанные с вводом-выводом.

Java-пакеты реализуют так называемое пространство имен (namespace), позволяющее использовать в проекте файлы с одинаковыми именами. Такой подход существует с давних времен во многих языках.

Пакетом (пространством имен) в Java называется структура вложенных по какому-то признаку папок с размещенными в них **классами** (интерфейсами, перечислениями, аннотациями), необходимыми проекту.

**Повторяющиеся имена классов** в Java в рамках одного проекта — обычное явление, которое не приводит к конфликтам имен только потому, что они хранятся в разных пакетах.

Имена пакетов пишутся строчными буквами, чтобы избежать конфликта с именами классов или интерфейсов.

Если классы находятся в **одном пакете** и используют возможности друг друга, то **выполнять import не нужно**, т. к. они смогут найти друг друга без каких-либо сложностей.

Это связано с тем, что в каждый класс автоматически импортируются все классы из текущего пакета. Текущий пакет — это пакет, в котором лежит текущий класс.

Получается, что в любой класс Java сама импортирует два пакета: текущий и java.lang.

### 4. Примитивные и ссылочные типы данных. Использование мехаизмов автоупаковки и автораспаковки. Операция приведения типов. Понижающее и повышающее приведение.
Примитивные типы данных Java — это основа, на которой держится всё.

- примитивные типы java, хранят непосредственно значение байтов данных (подробнее типы этих примитивов мы разберем немного ниже)
- ссылочный тип, хранит байты адреса объекта в Heap, то есть через эти переменные мы получаем доступ непосредственно к самому объекту(такой себе пульт от объекта)

### Примитивные типы данных
### byte
Итак, история подарила нам байт – минимальный объём памяти, который мы можем использовать. И состоит он из 8 бит. Самый маленький целый тип данных в java – byte. Это знаковый 8-битовый тип. Что это значит?

![image](https://github.com/mireashik/java_3sem/assets/49165758/b3945e40-ae42-4547-a2a5-b2f4ad607899)

### short
Лимит значений из byte довольно мал. Поэтому, для следующего типа данных решили увеличить количество бит вдвое. То есть теперь не 8 бит, а 16. То есть 2 байта.
<br>
Значит, диапазон от -32768 до 32767.

### int
Занимает он 32 бита, или 4 байта. В общем, мы продолжаем удваивать. Диапазон значений от -2^31 до 2^31 – 1.

Как выше было указано, для оптимизации вычислений, т.к. современным компьютерам с учетом их разрядности удобнее считать, данные могут быть неявно преобразованы к int. Вот простой пример:

Дело обстоит в том, что при работе с int значениями остаток отбрасывается, оставляя только целую часть(в таких случая лучше уж использовать double).

### long
Продолжаем удваивать. 32 умножаем на 2 и получаем 64 бита. По традиции, это 4 * 2, то есть 8 байт. Диапазон значений от -2^63 до 2^63 – 1. Более чем достаточно.

### Java float и Java double
Данные типы называются типами с плавающей точкой. То есть это не целочисленные типы.  Тип float является 32битным (как int), а **double** называется типом с **двойной** точностью, поэтому он 64битный (умножаем на 2, всё как мы любим).

### Java boolean
Следующий тип – булевский (логический тип). Он может принимать значения только true или false, которые являются ключевыми словами.

### Java char
Итак, данные в char занимают 16 бит и описывают символ. В Java для char используется кодировка Unicode.

![image](https://github.com/mireashik/java_3sem/assets/49165758/88c1d4d9-8231-481b-849b-b6785941b9ab)

### Литералы
Литерал - явно заданное значение.  При помощи литералов можно указывать значения в разных системах счисления:
- Десятеричная система: 10
- Шестнадцатеричная система: 0x1F4, начинается с 0x
- Восьмеричная система: 010, начинается с нуля.
- Двоичная система (начиная с Java7): 0b101, начинается с 0b

### Классы-обертки
Примитивы в Java имеют свои классы-обертки, чтобы можно было работать с ними как с объектами.
<br>
То есть, для каждого **примитивного типа существует, соответствующий ему ссылочный тип.**

Классы-обертки являются **immutable** (неизменяемыми): это означает, что после создания объекта его состояние — значение поля value — не может быть изменено.
<br>
Классы-обертки задекларированы как **final**: объекты, так сказать, read-only.

![image](https://github.com/mireashik/java_3sem/assets/49165758/43fc3e24-f966-4937-b3ff-6ccd66ad01cd)

![image](https://github.com/mireashik/java_3sem/assets/49165758/54fa2686-1910-4afc-930f-2d94b79f6899)

### Ссылочный тип данных
Что делать? Нельзя же вложить объект в переменную.

Ссылочные переменные хранят **адрес ячейки памяти**, в которой расположен определенный **объект**. То есть это “визитка” с адресом, имея которую мы можем найти наш объект в общей памяти и выполнять с ним некоторые манипуляции.

Ссылочные типы данных ещё называют ссылками. К ним относятся все классы, интерфейсы, массивы, а также тип данных String.

Ссылка на **любой объект** в Java представляет собой ссылочную переменную.

```java
TV telly = new TV();
```

Переменной типа TV с именем telly мы задаем ссылку на создаваемый объект типа TV. То есть, JVM выделяет память в куче под объект TV, создает его и адрес на его местоположение в памяти, кладется в переменную telly, которая хранится в стеке.

#### Переопределение ссылочных переменных
### Класс String
Это базовый класс, предназначен для хранения и работы с данными, которые хранятся в виде строки.

По популярности использования String не уступает примитивным типам, но всё же это класс, и переменная, которая ссылается на него — не примитивного, а ссылочного типа. 

Важным нюансом является то, что String — это неизменяемый класс.

### Ссылочные константы
```java
final TV telly = new TV();
```

То есть final действует только на ссылку, а на сам объект влияния не оказывает. Если изначально он у нас изменяемый, мы без проблем можем менять его внутреннее состояние:

А что если обозначить final ссылочную переменную, которая ссылается на неизменяемый объект? К примеру String:

```java
final String PASSWORD = "password";
```
Возможно, вы подумаете, что это сделает объект неизменяемым. Но нет, это не так. 

Как следствие, мы получим **константу - аналог констант примитивного типа**, ведь тут мы не можем ни переопределить ссылку, ни изменить внутреннее состояние объекта (внутренние данные).

![image](https://github.com/mireashik/java_3sem/assets/49165758/4d62aede-b3e4-413d-9969-d4581a37a693)

### Использование мехаизмов автоупаковки и автораспаковки
Обобщение означает параметризированный тип. Обобщения позволяют создавать классы, интерфейсы и методы, в которых тип данных указывается в виде параметра. С помощью обобщений можно создавать класс, который будет автоматически работать с разными типами данных. Такие классы, интерфейсы и методы называются **обобщенными**, как например, обобщенный класс или обобщенный метод.

Например, сортировка не зависит от типа данных, будь то String, Student или любой другой пользовательский класс, объекты которого можно сравнить между собой. 

Для преодоления этой проблемы в Java предусмотрен механизм автоупаковки (autoboxing) и автораспаковки (unboxing), который позволяет использовать классы-оболочки типов данных (их еще называют "обертки", wrapper).

Для решения этой проблемы в Java предусмотрены классы-обертки (wrappers). Классы-обертки реализуются в классах Double, Float, Long, Integer, Short, Byte, Character и Boolean. Все обертки числовых типов данных являются производными от абстрактного класса Number.

Процесс преобразования значения примитивного типа в объект соответствующего класса-обертки называется **упаковкой** (boxing).

Процесс извлечения значения примитивного типа из объекта-обертки называется **распаковкой** (unboxing).

**Автоупаковка** - процесс автоматической упаковки (инкапсуляции) простого типа данных в объектную обертку без необходимости явного создания объекта.

**Автораспаковка** - это обратный процесс автоматической распаковки (извлечения) значения, упакованного в объектную оболочку.

Автоупаковка является механизмом для скрытого преобразования примитивных типов данных в соответствующие классы-оболочки(объекты). Компилятор использует метод **valueOf()** чтобы преобразовать примитивные типы в объекты, а методы IntValue(), doubleValue() и т.д., чтобы получить примитивные типы объекта. Автоупаковка преобразует логический тип boolean в Boolean, byte в Byte, char в Character,  float в Float, int в Integer, long в Long, short в Short. Распаковка происходит в обратном направлении.

### Понижающее и повышающее приведение
Понижающее приведение (narrowing conversion) используется, когда переменной присваивается значение, которое не может поместиться в текущий тип переменной. 

Повышающее приведение (widening conversion) используется, когда переменной присваивается значение меньшего типа, чем ее текущий тип.

### 5. Этапы проектирования, разработки и отладки ООП программ. Понятие конвенции кода языка и стиля программирования.

### 10. Виды типов данных в Джава. Объектные типы данных
- String
- Arrays
- Классы и объекты
- Специальные классы для работы с коллекциями
- enums (Перечисления):
- Wrapper-классы

### 11. Объявление и использование бестиповых переменных в Джава
```java
// Объявление списка с элементами типа String
List<String> stringList = new ArrayList<>();
stringList.add("Привет");
stringList.add("Мир");

// Объявление карты с ключами типа Integer и значениями типа Double
Map<Integer, Double> myMap = new HashMap<>();
myMap.put(1, 3.14);
myMap.put(2, 2.71);
```

```
public class Box<T> {
    private T value;

    public void setValue(T value) {
        this.value = value;
    }

    public T getValue() {
        return value;
    }
}
```

Во всех случаях, кроме заголовка класса, символ T пишется без угловых скобок, он обозначает один и тот же параметр типа.

Параметром типа для дженерика может быть только ссылочный тип, интерфейс или перечисление (enum). Примитивные типы и массивы с дженериками не используются, то есть нельзя создать Box<int> или Box<int[]>, но можно — Box<Integer> или Box<List<Integer>>.

### 12. Объявление переменных типа класс и их инициализация

```java
public class Cat {

    String name;
    int age;

    static int count = 0;

    public static void main(String[] args) {
        Cat barsik = new Cat();
        barsik.age = 3;
        barsik.name = "Барсик";
        count++;

        Cat vasia = new Cat();
        vasia.age = 5;
        vasia.name = "Вася";
        count++;

        System.out.println("Мы создали кота по имени " + barsik.name + ", его возраст - " + barsik.age);
        System.out.println("Мы создали кота по имени " + vasia.name + ", его возраст - " + vasia.age);

        System.out.println("Общее количество котов = " + count);
    }
}
```

Теперь у нас в классе появилась новая переменная — **count** (количество). Она отвечает за **подсчет созданных котов**. Каждый раз, когда в методе main мы создаем кота, мы увеличиваем эту переменную на 1.

Эта переменная обозначена ключевым словом **static**. Это значит, что она принадлежит классу, а не конкретному объекту класса. Что, конечно, логично: если имя у каждого кота должно быть свое, то счетчик котов нам нужен один на всех. Именно этого позволяет добиться слово static — переменная count одна для всех котов.

### Конструкторы
```java
public class Cat {

    String name;
    int age;

    //конструктор для класса Cat
    public Cat(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public static void main(String[] args) {

        Cat barsik = new Cat("Barsik", 5);
    }
}
```

Мы не смогли создать кота без имени и возраста, потому что определили конструктор для Cat: строка + число.

Дефолтный конструктор сразу после этого исчез из класса.

### 13. Массивы в Джава, как объектные типы данных, контроль доступа за выход за границы массива. Объявление и инициализация массивов, длина массива, получение доступа к элементу массива
Ты уже слышал, что массивы объектов и массивы примитивов по-разному хранятся в памяти. Возьмём, например, массив из трех объектов Cat:

```java
public class Cat {

   private String name;

   public Cat(String name) {
       this.name = name;
   }

   public static void main(String[] args) {

       Cat[] cats = new Cat[3];
       cats[0] = new Cat("Томас");
       cats[1] = new Cat("Бегемот");
       cats[2] = new Cat("Филипп Маркович");
   }
}
```

1. В случае с примитивами массивы Java хранят множество конкретных значений (например, чисел int). В случае с объектами **массив хранит множество ссылок**. Массив cats состоит из трех ячеек, в каждой из которых есть ссылка на объект Cat. Каждая из ссылок указывает на адрес в памяти, где этот объект хранится.
2. Элементы массива в памяти размещаются в едином блоке. Это сделано для более эффективного и быстрого доступа к ним. Таким образом, ссылка cats указывает на блок в памяти, где хранятся все объекты — элементы массива. А cats[0] — на конкретный адрес внутри этого блока.

### 14. Способы объявления массивов в Джава, использование операции new для выделения памяти для элементов массива. Объявление с инициализацией, объявление массива определенного размера без инициализации.
В Java существует несколько способов объявления массивов, включая различные способы использования оператора `new` для выделения памяти для элементов массива. Вот несколько примеров:

### Объявление с инициализацией:

1. **Инициализация при объявлении:**

   ```java
   // Объявление и инициализация массива строк
   String[] myArray1 = {"один", "два", "три"};
   
   // Объявление и инициализация массива целых чисел
   int[] myArray2 = {1, 2, 3, 4, 5};
   ```

2. **Объявление и инициализация отдельно:**

   ```java
   // Объявление массива строк
   String[] myArray;
   
   // Инициализация массива при помощи оператора new
   myArray = new String[]{"Java", "JavaScript", "Python"};
   ```

### Объявление массива определенного размера без инициализации:

```java
// Объявление массива целых чисел размером 5
int[] myIntArray = new int[5];

// Объявление массива строк размером 3
String[] myStringArray = new String[3];
```

При использовании оператора `new` для создания массива без явной инициализации, элементы получают значения по умолчанию для их типа данных (например, 0 для числовых типов, `null` для ссылочных типов).

Необходимо отметить, что размер массива указывается в момент его создания и не может быть изменен после этого. Если вам нужна динамическая структура данных, рекомендуется использовать коллекции из пакета `java.util`, такие как `ArrayList`.

```java
// Использование ArrayList для динамического списка строк
import java.util.ArrayList;

ArrayList<String> dynamicList = new ArrayList<>();
dynamicList.add("Java");
dynamicList.add("JavaScript");
dynamicList.add("Python");
```

### 15. Инициализация полей класса и локальных переменных (отличие), инициализатор и статический инициализатор (когда вызывается)
**Поля класса** инициализируются при создании экземпляра класса. 

```java
public class MyClass {
    int myInt;            // По умолчанию 0
    String myString;      // По умолчанию null
}
```

**Локальные переменные** (в том числе параметры методов) должны быть **явно инициализированы** перед использованием. Они **не получают значения по умолчанию**, и попытка использования неинициализированной переменной приведет к ошибке компиляции.

```java
public void myMethod() {
    int localVar;  // Ошибка компиляции - локальную переменную нужно инициализировать перед использованием
    // ...
}
```

**Инициализатор** - это блок кода внутри класса, который используется для инициализации экземплярных переменных (полей) объекта. Он выполняется каждый раз при создании объекта класса перед вызовом конструктора.
<br>
**Инициализатор** - это блок кода внутри класса, который выполняется при создании объекта класса.

**Нестатический (instance) инициализатор** - это блок кода, который выполняется каждый раз при создании нового объекта класса. 

```java
public class MyClass {
    int myInt;
    {
        // Инициализатор
        myInt = 42;
    }

    // Конструктор
    public MyClass() {
        // ...
    }
}
```

Статический инициализатор - это блок кода, который используется для инициализации статических переменных класса. Он выполняется при первой загрузке класса в память, до создания экземпляров класса или вызова статических методов.

```java
public class MyClass {
    static int staticInt;
    static {
        // Статический инициализатор
        staticInt = 99;
    }
}
```

### 16. Циклические конструкции в Java. Использование циклов для работы с массивами. Использование итераторов для обработки массивов. Использование итераторов для работы с коллекциями
Циклы для массивов

```java
int[] myArray = {1, 2, 3, 4, 5};

for (int i = 0; i < myArray.length; i++) {
    // Обработка элементов массива
    System.out.println(myArray[i]);
}
```

```java
int[] myArray = {1, 2, 3, 4, 5};

for (int element : myArray) {
    // Обработка элементов массива
    System.out.println(element);
}
```

В Java итераторы часто используются с коллекциями, но не столь распространены с массивами. Тем не менее, вы можете использовать Arrays.asList для преобразования массива в список и затем использовать итератор:

```java
import java.util.Arrays;
import java.util.Iterator;
import java.util.List;

public class Main {
    public static void main(String[] args) {
        int[] myArray = {1, 2, 3, 4, 5};
        List<Integer> myList = Arrays.asList(Arrays.stream(myArray).boxed().toArray(Integer[]::new));

        Iterator<Integer> iterator = myList.iterator();
        while (iterator.hasNext()) {
            // Обработка элементов списка
            System.out.println(iterator.next());
        }
    }
}
```

```java
import java.util.ArrayList;
import java.util.Iterator;

public class Main {
    public static void main(String[] args) {
        ArrayList<String> myArrayList = new ArrayList<>();
        myArrayList.add("Java");
        myArrayList.add("Python");
        myArrayList.add("JavaScript");

        Iterator<String> iterator = myArrayList.iterator();
        while (iterator.hasNext()) {
            // Обработка элементов списка
            System.out.println(iterator.next());
        }
    }
}
```

```java
import java.util.ArrayList;

public class Main {
    public static void main(String[] args) {
        ArrayList<String> myArrayList = new ArrayList<>();
        myArrayList.add("Java");
        myArrayList.add("Python");
        myArrayList.add("JavaScript");

        for (String element : myArrayList) {
            // Обработка элементов списка
            System.out.println(element);
        }
    }
}
```

### 17. Статические поля и методы. Класс Math, его основные методы.
### Статические поля и методы:

В Java статические поля и методы принадлежат классу, а не конкретному экземпляру класса. Они могут быть вызваны без создания объекта данного класса и обычно используются для предоставления общей функциональности всему классу. Вот пример:

```java
public class MyClass {
    // Статическое поле
    public static int staticField = 42;

    // Статический метод
    public static void staticMethod() {
        System.out.println("Статический метод вызван");
    }
}
```

Использование статического поля и метода:

```java
// Доступ к статическому полю
int value = MyClass.staticField;

// Вызов статического метода
MyClass.staticMethod();
```

### Класс `Math` и его основные методы:

Класс `Math` в Java предоставляет методы для выполнения математических операций. Все его методы и поля являются статическими. Ниже приведены некоторые из основных методов класса `Math`:

1. **`abs`:**
   - Возвращает абсолютное значение числа.
   ```java
   int absoluteValue = Math.abs(-5); // Вернет 5
   ```

2. **`sqrt`:**
   - Возвращает квадратный корень числа.
   ```java
   double squareRoot = Math.sqrt(16); // Вернет 4.0
   ```

3. **`pow`:**
   - Возводит число в указанную степень.
   ```java
   double powerResult = Math.pow(2, 3); // Вернет 8.0
   ```

4. **`sin`, `cos`, `tan`:**
   - Тригонометрические функции: синус, косинус, тангенс (в радианах).
   ```java
   double sinValue = Math.sin(Math.PI / 2); // Вернет 1.0
   ```

5. **`random`:**
   - Возвращает случайное число в диапазоне от 0.0 (включительно) до 1.0 (исключительно).
   ```java
   double randomValue = Math.random(); // Вернет случайное число между 0.0 и 1.0
   ```

6. **`ceil`, `floor`:**
   - Округление вверх и вниз.
   ```java
   double ceilValue = Math.ceil(4.2); // Вернет 5.0
   double floorValue = Math.floor(4.9); // Вернет 4.0
   ```

7. **`round`:**
   - Округление до ближайшего целого числа.
   ```java
   long roundedValue = Math.round(4.6); // Вернет 5
   ```

8. **`max`, `min`:**
   - Возвращает максимальное и минимальное из двух чисел.
   ```java
   int maxResult = Math.max(10, 5); // Вернет 10
   int minResult = Math.min(10, 5); // Вернет 5
   ```

Это лишь несколько примеров методов класса `Math`. Класс предоставляет богатый набор математических функций для различных потребностей.

### 18. Понятие перечисления. Состав и приемы использования в ООП программах на Jаva
Кроме отдельных примитивных типов данных и классов в Java есть такой тип как enum или перечисление. Перечисления представляют набор логически связанных констант. Объявление перечисления происходит с помощью оператора enum, после которого идет название перечисления. Затем идет список элементов перечисления через запятую:

```java
 
    MONDAY,
    TUESDAY,
    WEDNESDAY,
    THURSDAY,
    FRIDAY,
    SATURDAY,
    SUNDAY
}
```

Enum — тоже класс. Но он специально «заточен» на решение задач, похожих на нашу: создание некоторого ограниченного круга значений.

```java
public enum Day {
    MONDAY("Понедельник"), TUESDAY("Вторник"), WEDNESDAY("Среда");

    private String russianName;

    Day(String russianName) {
        this.russianName = russianName;
    }

    public String getRussianName() {
        return russianName;
    }
}
```

```java
Day[] days = Day.values(); // Возвращает массив, содержащий все константы перечисления
```

```java
Day wednesday = Day.valueOf("WEDNESDAY"); // Возвращает константу перечисления по ее имени
```

```java
public enum TrafficLight implements Signal {
// Здесь TrafficLight реализует интерфейс Signal, добавляя метод getMessage для каждой константы.
    RED, YELLOW, GREEN;

    @Override
    public String getMessage() {
        return "The traffic light is " + this.name();
    }
}
```
### 20. Понятие класса. Определение, инициализация. Модификаторы доступа. Константы и переменные. Объявление классов
### Понятие класса:

**Класс** в программировании представляет собой шаблон или чертёж для создания объектов. Он определяет состояние (переменные), поведение (методы) и их взаимодействие. Объекты созданные на основе класса, обладают своими уникальными характеристиками.

### Объявление класса:

```java
public class MyClass {
    // Переменные (состояние)
    private int myInt;
    private String myString;

    // Методы (поведение)
    public void setMyInt(int value) {
        myInt = value;
    }

    public int getMyInt() {
        return myInt;
    }

    public void setMyString(String value) {
        myString = value;
    }

    public String getMyString() {
        return myString;
    }
}
```

### Инициализация класса:

```java
MyClass obj = new MyClass(); // Создание объекта класса MyClass
obj.setMyInt(42);
obj.setMyString("Hello, World!");

System.out.println(obj.getMyInt());    // Вывод: 42
System.out.println(obj.getMyString()); // Вывод: Hello, World!
```

### Модификаторы доступа:

- **`public`:** Класс, метод или поле видны из любого места.
- **`private`:** Класс, метод или поле видны только внутри своего класса.
- **`protected`:** Класс, метод или поле видны внутри своего класса, подклассов и пакета.
- **`default` (по умолчанию):** Если не указан модификатор доступа, то класс, метод или поле видны только внутри своего пакета.

### Константы и переменные:

- **Константы:** Используются ключевое слово `final` и обычно именуются заглавными буквами с подчеркиванием.
  ```java
  public static final int MAX_VALUE = 100;
  ```

- **Переменные:** Могут изменять свои значения. Могут быть разных типов (примитивные или объектные).
  ```java
  private int counter;
  ```

### 30. Получение информации о типе. Создание экземпляров классов. Вызов методов класса Объявление класса на Джава, пример объявления
В Java для получения информации о типе объекта или переменной можно использовать оператор instanceof или метод getClass(). Ниже приведены примеры использования обоих подходов:

### Получение информации о типе:

В Java для получения информации о типе объекта или переменной можно использовать оператор `instanceof` или метод `getClass()`. Ниже приведены примеры использования обоих подходов:

1. **Оператор `instanceof`:**
   ```java
   Object obj = "Hello, World!";
   if (obj instanceof String) {
       System.out.println("Это строка");
   }
   ```

2. **Метод `getClass()`:**
   ```java
   Object obj = 42;
   Class<?> type = obj.getClass();
   System.out.println("Тип объекта: " + type.getName());
   ```

### Создание экземпляров классов:

Для создания экземпляра класса используется оператор `new`, за которым следует вызов конструктора класса. Вот пример:

```java
// Создание экземпляра класса String
String myString = new String("Hello, World!");

// Создание экземпляра класса Car
Car myCar = new Car("Toyota", 2022);
```

### Вызов методов класса:

После создания экземпляра класса, его методы могут быть вызваны с использованием точечной нотации. Вот пример:

```java
// Вызов метода на экземпляре класса String
int length = myString.length();

// Вызов методов на экземпляре класса Car
myCar.startEngine();
myCar.stopEngine();
```

### 31. ООП в Java. Понятие объекта. Что представляет собой Java приложение с точки зрения ООП. Основные характеристики объектов в Java
### ООП в Java:

**Объектно-ориентированное программирование (ООП)** в Java является ключевой парадигмой, в основе которой лежит концепция объектов. В Java почти всё является объектом, что позволяет разрабатывать модульные и повторно используемые программы. ООП в Java включает следующие основные принципы:

1. **Инкапсуляция (Encapsulation):**
   - Сокрытие деталей реализации и предоставление интерфейса для взаимодействия с внешним миром. Пример: использование приватных и защищенных членов класса, геттеров и сеттеров.

2. **Наследование (Inheritance):**
   - Возможность создания нового класса на основе существующего, заимствуя его свойства и методы. Позволяет создавать иерархии классов. Пример: `extends` при определении подкласса.

3. **Полиморфизм (Polymorphism):**
   - Возможность использования объектов разных типов с использованием общего интерфейса. Включает перегрузку методов и переопределение методов в подклассах. Пример: перегрузка методов, использование интерфейсов и абстрактных классов.

### Понятие объекта:

**Объект** в Java представляет экземпляр класса. Это конкретное воплощение концепции, описанной в классе. Объекты состоят из данных (переменных класса) и методов (функций класса), которые манипулируют этими данными. Например:

```java
// Объекты класса String
String greeting1 = new String("Привет, мир!");
String greeting2 = new String("Hello, World!");

// Объект класса Car
Car myCar = new Car("Toyota", 2022);
```

### Java приложение с точки зрения ООП:

В Java приложение рассматривается как совокупность взаимодействующих объектов. Программы в Java строятся на основе классов, каждый из которых представляет собой модель некоторой сущности. Эти классы могут взаимодействовать друг с другом через методы и данные.

Пример Java приложения с использованием ООП:

```java
// Класс представляющий точку в 2D пространстве
class Point {
    private int x;
    private int y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public void printCoordinates() {
        System.out.println("Координаты точки: (" + x + ", " + y + ")");
    }
}

// Главный класс приложения
public class Main {
    public static void main(String[] args) {
        // Создание объекта класса Point
        Point myPoint = new Point(10, 20);

        // Использование метода объекта
        myPoint.printCoordinates();
    }
}
```

### Основные характеристики объектов в Java:

1. **Состояние (State):**
   - Переменные экземпляра класса представляют его состояние. Например, переменные `x` и `y` в классе `Point`.

2. **Поведение (Behavior):**
   - Методы класса определяют его поведение. Например, метод `printCoordinates` в классе `Point`.

3. **Идентичность (Identity):**
   - Каждый объект обладает уникальной идентичностью, определенной его местоположением в памяти.

4. **Инкапсуляция (Encapsulation):**
   - Сокрытие деталей реализации объекта и предоставление интерфейса для его использования.

5. **Наследование (Inheritance):**
   - Возможность создания иерархии классов и создания новых классов на основе существующих.

6. **Полиморфизм (Polymorphism):**
   - Возможность использования объектов разных типов с использованием общего интерфейса.
  
### 31. Конструкторы, назначение и использование. Конструктор с параметром, конструктор по умолчанию
### Конструкторы в Java:

**Конструктор** в Java - это специальный метод, который вызывается при создании объекта. Он используется для инициализации объектов, устанавливая начальные значения полей класса или выполняя другие действия, необходимые при создании объекта. Конструкторы имеют то же имя, что и класс, и не возвращают значения.

### Назначение и использование конструкторов:

1. **Инициализация объектов:**
   - Конструкторы выполняют инициализацию объектов, устанавливая начальные значения переменных.

2. **Избежание дублирования кода:**
   - Использование конструкторов позволяет избежать дублирования кода для инициализации объектов в различных частях программы.

3. **Предоставление различных вариантов инициализации:**
   - Класс может иметь несколько конструкторов с различными параметрами, предоставляя различные варианты инициализации.

### Конструктор с параметром:

```java
public class Car {
    private String model;
    private int year;

    // Конструктор с параметрами
    public Car(String model, int year) {
        this.model = model;
        this.year = year;
    }

    // Другие методы класса...
}
```

Пример использования конструктора с параметром:

```java
// Создание объекта с использованием конструктора с параметрами
Car myCar = new Car("Toyota", 2022);
```

### Конструктор по умолчанию:

Если в классе не определен ни один конструктор, то по умолчанию компилятор Java предоставит **конструктор по умолчанию**, который не принимает параметров и выполняет базовую инициализацию.

Пример:

```java
public class Person {
    private String name;
    private int age;

    // Конструктор по умолчанию
    public Person() {
        // Базовая инициализация
        name = "Unknown";
        age = 0;
    }

    // Другие методы класса...
}
```

Пример использования конструктора по умолчанию:

```java
// Создание объекта с использованием конструктора по умолчанию
Person defaultPerson = new Person();
```

Важно отметить, что если в классе определен хотя бы один конструктор, то конструктор по умолчанию компилятором не будет предоставлен. Если вам нужен конструктор по умолчанию, и в классе уже определен как минимум один конструктор, вы должны явно добавить конструктор по умолчанию.

### 33. Конструкторы, назначение и использование. Вызов конструктора родительского класса, неявный вызов конструктора родительского класса, порядок инициализации экземпляра Java класса.
### Вызов конструктора родительского класса:

1. **Явный вызов конструктора родительского класса:**
   - Используется ключевое слово `super` для вызова конструктора родительского класса.

   ```java
   public class ChildClass extends ParentClass {
       public ChildClass() {
           super(); // Явный вызов конструктора родительского класса
           // Дополнительные действия для конструктора ChildClass
       }
   }
   ```

2. **Неявный вызов конструктора родительского класса:**
   - Если в дочернем классе не указан явный вызов конструктора родительского класса, то неявно вызывается конструктор по умолчанию родительского класса.

   ```java
   public class ChildClass extends ParentClass {
       // Конструктор ChildClass без явного вызова конструктора родительского класса
   }
   ```

### Порядок инициализации экземпляра Java класса:

При создании объекта в Java происходит следующий порядок инициализации:

1. **Инициализация переменных по умолчанию:**
   - Все переменные объекта получают значения по умолчанию (нулевые значения для примитивных типов, `null` для объектных).

2. **Выполнение блока инициализации (если есть):**
   - Если в классе есть блок инициализации, он выполняется после инициализации переменных по умолчанию.

   ```java
   public class MyClass {
       {
           // Блок инициализации
       }
   }
   ```

3. **Выполнение конструктора родительского класса:**
   - Если объект является наследником, вызывается конструктор родительского класса.

4. **Выполнение конструктора текущего класса:**
   - Вызывается конструктор текущего класса.

Пример:

```java
public class Example {
    private int x;

    // Блок инициализации
    {
        x = 42;
    }

    // Конструктор класса
    public Example() {
        // Дополнительные действия при создании объекта
    }
}
```

Этот порядок обеспечивает корректную инициализацию объекта и его переменных перед использованием.

![image](https://github.com/mireashik/java_3sem/assets/49165758/8f1ca0c9-f109-4789-9d5b-25bf2348860a)
