### 77. Понятие исключительной ситуации, причины возникновения, механизм обработки. Классификация исключений. Исключения, классификация и использование исключений. Генерация (порождение исключений).
Исключительная ситуация (или исключение) в программировании - это событие, которое нарушает нормальный поток выполнения программы. Оно может возникнуть из-за различных причин, таких как неправильный ввод данных, ошибка во время выполнения программы, недоступность ресурсов и т. д.

### Причины возникновения исключений:

1. **Ошибки ввода-вывода (IOException)**: Например, попытка доступа к файлу, который не существует, или попытка чтения данных из закрытого потока.

2. **Недопустимые аргументы (IllegalArgumentException)**: Например, передача в метод некорректных параметров.

3. **Отсутствие ресурсов (NullPointerException)**: Например, попытка обращения к объекту, который равен `null`.

4. **Деление на ноль (ArithmeticException)**: Попытка деления числа на ноль.

5. **Выход за границы массива (ArrayIndexOutOfBoundsException)**: Попытка доступа к элементу массива по индексу, выходящему за его границы.

### Механизм обработки исключений:

В Java исключения обрабатываются с помощью механизма try-catch. В блоке `try` помещается код, который может вызвать исключение. Затем в блоке `catch` указывается, как обработать это исключение, если оно произошло.

Пример:

```java
try {
    // Код, который может вызвать исключение
} catch (Exception e) {
    // Обработка исключения
    System.out.println("Произошло исключение: " + e.getMessage());
}
```

### Классификация исключений:

1. **Проверяемые исключения (Checked Exceptions)**: Это исключения, которые компилятор требует обрабатывать или объявлять. Например, `IOException`.

2. **Непроверяемые исключения (Unchecked Exceptions)**: Это исключения, которые не требуется обрабатывать или объявлять. Например, `NullPointerException`, `ArithmeticException`.

3. **Ошибка (Error)**: Это исключения, которые обычно указывают на проблемы, которые не могут быть исправлены в рамках программы. Например, `OutOfMemoryError`.

### Генерация (порождение исключений):

Исключение можно породить в программе с помощью ключевого слова `throw`. Это позволяет явно указать место, где возникает исключительная ситуация.

Пример:

```java
public void someMethod(int value) {
    if (value < 0) {
        throw new IllegalArgumentException("Значение не может быть отрицательным");
    }
    // Дальнейший код
}
```

В этом примере, если метод `someMethod()` вызывается с отрицательным значением, он порождает исключение `IllegalArgumentException`.

### 78. Служебное слово throw и его использование при определении методов. В каком случае программа должна использовать оператор throw? 
Ключевое слово `throw` в Java используется для явной генерации исключения в программе. Оно используется для создания собственных исключительных ситуаций, когда возникают ошибки или некорректные условия, которые должны быть обработаны в другом месте кода.

### Использование оператора throw:

1. **Создание нового экземпляра исключения**:
   ```java
   throw new SomeException("Сообщение об ошибке");
   ```
   Где `SomeException` - тип исключения, которое нужно создать, и `"Сообщение об ошибке"` - дополнительная информация об ошибке.

2. **Перехват предыдущего исключения и повторная генерация**:
   ```java
   try {
       // Какой-то код, который может вызвать исключение
   } catch (SomeException e) {
       throw new AnotherException("Дополнительное сообщение", e);
   }
   ```
   Здесь `AnotherException` - тип нового исключения, а `e` - исключение, которое было перехвачено и повторно сгенерировано.

### В каких случаях использовать оператор throw:

1. **При возникновении ошибки или исключительной ситуации**: Когда ваш код обнаруживает некорректное состояние или ошибку, которую невозможно обработать в текущем контексте, он может использовать оператор `throw`, чтобы сообщить об этой ситуации выше по стеку вызовов.

2. **При несоответствии входных данных**: Если ваш метод ожидает определенные типы данных или диапазоны значений, вы можете использовать оператор `throw`, чтобы сигнализировать об ошибке, когда входные данные не соответствуют этим ожиданиям.

3. **При недоступности ресурсов**: Если ваш код требует доступа к каким-то ресурсам, и эти ресурсы недоступны по какой-то причине (например, файл не найден, сетевое соединение разорвано), можно сгенерировать исключение с соответствующим сообщением.

В целом, оператор `throw` используется для явного указания на проблемы в вашем коде или внешних условиях, которые должны быть обработаны в другом месте программы.

### 79. Создание собственных классов исключений
В Java создание собственных классов исключений позволяет вам определять собственные типы исключений, которые отражают конкретные ситуации в вашем приложении. Для создания собственного класса исключения следуйте этим шагам:

1. **Создайте класс, наследующий от класса `Exception` или его подкласса**: Ваш класс исключения должен расширять класс `Exception` или один из его подклассов (например, `RuntimeException`, если вы хотите создать непроверяемое исключение).

2. **Определите конструкторы**: Обычно ваш класс исключения будет иметь несколько конструкторов для инициализации объекта исключения различными способами. Вы можете использовать конструкторы родительского класса `Exception` для передачи сообщений об ошибке.

3. **Дополнительно реализуйте любые другие методы, если это необходимо**: В зависимости от ваших потребностей, вы можете добавить дополнительные методы или поля в ваш класс исключения.

Вот пример создания собственного класса исключения:

```java
public class CustomException extends Exception {
    // Конструкторы
    public CustomException() {
        super();
    }

    public CustomException(String message) {
        super(message);
    }

    public CustomException(String message, Throwable cause) {
        super(message, cause);
    }

    public CustomException(Throwable cause) {
        super(cause);
    }

    // Дополнительные методы, если необходимо
}
```

Теперь вы можете использовать этот класс исключения в вашем коде, как и другие стандартные исключения:

```java
public class Main {
    public static void main(String[] args) {
        try {
            // Некоторый код, который может вызвать ваше собственное исключение
            throw new CustomException("Произошла собственная ошибка");
        } catch (CustomException e) {
            // Обработка вашего собственного исключения
            System.out.println("Поймано собственное исключение: " + e.getMessage());
        }
    }
}
```

Создание собственных классов исключений особенно полезно, когда вам нужно обработать конкретные ситуации, которые могут возникнуть в вашем приложении, и предоставить более информативные сообщения об ошибках для пользователей или разработчиков.

### 80. Блок try/catch/finally, его предназначение и особенности
Блок `try/catch/finally` в Java используется для обработки исключений и выполнения кода, который может вызвать исключение, а также для выполнения кода, который должен быть выполнен независимо от того, возникло исключение или нет. Этот блок имеет следующую структуру:

```java
try {
    // Код, который может вызвать исключение
} catch (ExceptionType1 e1) {
    // Обработка исключения типа ExceptionType1
} catch (ExceptionType2 e2) {
    // Обработка исключения типа ExceptionType2
} finally {
    // Код, который будет выполнен в любом случае
}
```

### Особенности блока try/catch/finally:

1. **try**: В блоке `try` помещается код, который может вызвать исключение. Если исключение происходит внутри этого блока, выполнение кода прекращается, и управление передается соответствующему блоку `catch`.

2. **catch**: Блоки `catch` предназначены для обработки исключений, которые могут быть сгенерированы в блоке `try`. Вы можете указать тип исключения, которое вы хотите перехватить, и код, который должен быть выполнен в этом случае.

3. **finally**: Блок `finally` содержит код, который должен быть выполнен независимо от того, возникло исключение или нет. Этот код будет выполнен даже в случае, если в блоке `try` нет исключений, и после всех блоков `catch`. Блок `finally` полезен для освобождения ресурсов или завершения операций, которые должны быть выполнены независимо от исключительной ситуации.

4. **Множественные блоки catch**: Вы можете иметь несколько блоков `catch`, чтобы обрабатывать разные типы исключений. Каждый блок `catch` должен обрабатывать исключение определенного типа или его подкласс.

5. **Необязательный finally**: Блок `finally` является необязательным. Вы можете использовать только блок `try` и не указывать блоки `catch` или `finally`, если вам не нужно обрабатывать исключения или выполнять код после блока `try`.

Блок `try/catch/finally` является основным механизмом обработки исключений в Java, который обеспечивает гибкость и надежность выполнения кода в различных сценариях.

### 81. В Java все исключения делятся на два основных типа. Что это за типы и какие виды ошибок ни обрабатывают?
В Java все исключения делятся на два основных типа:

1. **Проверяемые исключения (Checked Exceptions)**:
   - Это исключения, которые должны быть обработаны или объявлены в сигнатуре метода с помощью ключевого слова `throws`.
   - К таким исключениям относятся классы, наследующиеся от класса `Exception`, за исключением классов наследников `RuntimeException` и их подклассов.
   - Примеры проверяемых исключений включают `IOException`, `SQLException`, `ClassNotFoundException` и т. д.

2. **Непроверяемые исключения (Unchecked Exceptions)** (также называемые рантайм-исключениями):
   - Это исключения, которые не требуют явного обработчика исключений или объявления в сигнатуре метода.
   - К ним относятся классы, наследующиеся от класса `RuntimeException`, такие как `NullPointerException`, `ArrayIndexOutOfBoundsException`, `ArithmeticException` и другие.
   - Непроверяемые исключения обычно возникают в результате ошибок программиста или некорректного использования API, их обычно не следует пытаться перехватывать и обрабатывать.

Важно отметить, что непроверяемые исключения, в отличие от проверяемых, не требуют явного обработчика исключений. Однако обработка их все равно может быть полезной в некоторых случаях для обеспечения более гибкой и надежной работы программы.

### 82. Код ниже вызовет ошибку: Exception <...> java. lang.ArrayIndexOutOfBoundsException: 4: Что она означает?
Ошибка "ArrayIndexOutOfBoundsException" означает, что ваш код пытается получить доступ к элементу массива по индексу, который находится за пределами допустимого диапазона индексов массива. В данном случае, вы пытаетесь получить доступ к элементу массива по индексу 4, но ваш массив не содержит элемента с таким индексом.

Например, если у вас есть массив `arr` с тремя элементами (`arr[0]`, `arr[1]`, `arr[2]`), то индексы доступны только от 0 до 2. Если вы попытаетесь обратиться к элементу `arr[3]` или больше, это приведет к ошибке `ArrayIndexOutOfBoundsException`.

В вашем конкретном случае, чтобы избежать этой ошибки, убедитесь, что индексы, которые вы используете для доступа к элементам массива, находятся в допустимом диапазоне индексов этого массива.

### 83. Контролируемые исключения (checked) и неконтролируемые исключения (unchecked) и ошибки, которые они обрабатывают
В Java исключения и ошибки делятся на три основных категории: проверяемые исключения (checked exceptions), непроверяемые исключения (unchecked exceptions) и ошибки (errors).

1. **Проверяемые исключения (Checked Exceptions)**:
   - Проверяемые исключения - это исключения, которые должны быть обработаны или объявлены в сигнатуре метода с помощью ключевого слова `throws`.
   - Они наследуются от класса `Exception`, но не от `RuntimeException` или его подклассов.
   - Примеры проверяемых исключений включают `IOException`, `SQLException`, `ClassNotFoundException` и другие, которые обычно связаны с ошибками ввода-вывода, работой с базами данных и т. д.

2. **Непроверяемые исключения (Unchecked Exceptions)**:
   - Непроверяемые исключения (также называемые рантайм-исключениями) - это исключения, которые не требуют явного обработчика исключений или объявления в сигнатуре метода.
   - Они наследуются от класса `RuntimeException` или его подклассов.
   - Примеры непроверяемых исключений включают `NullPointerException`, `ArrayIndexOutOfBoundsException`, `ArithmeticException` и другие, которые обычно связаны с ошибками программирования, например, неправильной работой с объектами или недопустимыми операциями.

3. **Ошибки (Errors)**:
   - Ошибки - это серьезные проблемы, которые обычно связаны с невозможностью корректной работы приложения.
   - Они наследуются от класса `Error`.
   - Примеры ошибок включают `OutOfMemoryError`, `StackOverflowError`, `NoClassDefFoundError` и другие, которые обычно связаны с проблемами с памятью, стеком вызовов, загрузкой классов и т. д.

Контролируемые исключения обычно возникают в результате внешних ситуаций, которые программа должна обрабатывать, например, ошибки ввода-вывода или недоступность ресурсов. Неконтролируемые исключения, с другой стороны, обычно возникают в результате ошибок программирования или непредвиденных условий, которые программа не может обработать. Ошибки обычно возникают из-за серьезных проблем, которые выходят за пределы управления программы, и обычно не предназначены для обработки в коде приложения.

### 84. Как реализуется принципы ООП в Java при создании исключений? Порядок выполнения операторов при обработке блока блока try...catch
Принципы объектно-ориентированного программирования (ООП) в Java применяются при создании исключений в следующих аспектах:

1. **Наследование**: В Java исключения являются объектами классов. Класс исключения может наследоваться от других классов и расширять функциональность с помощью наследования. Например, пользовательские исключения часто наследуются от классов `Exception` или `RuntimeException`.

2. **Инкапсуляция**: Исключения обычно инкапсулируют информацию об ошибке, такую как сообщение об ошибке, стек вызовов и т. д. Эта информация доступна через методы доступа (геттеры) в классе исключения, что обеспечивает безопасный доступ к данным об ошибке.

3. **Полиморфизм**: Исключения в Java позволяют использовать полиморфизм. Это означает, что вы можете обрабатывать различные типы исключений общим способом с использованием общего типа исключения (например, обработка `Exception` вместо конкретных классов исключений).

При обработке блока `try...catch` в Java операторы выполняются следующим образом:

1. Код внутри блока `try` выполняется по порядку сверху вниз.
2. Если внутри блока `try` не возникает исключение, выполнение продолжается после блока `catch`.
3. Если внутри блока `try` возникает исключение, оставшийся код внутри блока `try` не выполняется, и выполнение передается блоку `catch`, который соответствует типу исключения.
4. После выполнения блока `catch` или если исключение не возникло, выполнение продолжается с блока `finally`, если он присутствует.
5. Блок `finally` выполняется в любом случае, независимо от того, возникло исключение или нет, и независимо от того, было ли исключение успешно обработано.

Это позволяет обеспечить надежное выполнение кода и обработку исключений в Java.

### 85. Абстрактный тип данных Stack (cтек) в Джава
В Java стек реализуется с помощью класса `java.util.Stack`, который представляет собой стек объектов. Стек - это коллекция, в которой элементы добавляются и удаляются только с одного конца, называемого вершиной стека. Принцип работы стека можно представить как "последний вошел - первый вышел" (Last-In, First-Out, LIFO).

Вот основные методы класса `Stack`:

1. `push(E item)`: Добавляет элемент на вершину стека.
2. `pop()`: Удаляет и возвращает элемент с вершины стека.
3. `peek()`: Возвращает элемент с вершины стека без его удаления.
4. `empty()`: Проверяет, пуст ли стек.
5. `search(Object o)`: Возвращает позицию элемента от вершины стека. Если элемент не найден, возвращается -1.

Пример использования:

```java
import java.util.Stack;

public class Main {
    public static void main(String[] args) {
        Stack<Integer> stack = new Stack<>();

        // Добавляем элементы на стек
        stack.push(10);
        stack.push(20);
        stack.push(30);

        // Выводим содержимое стека
        System.out.println("Содержимое стека: " + stack);

        // Удаляем элемент с вершины стека и выводим его
        int removedElement = stack.pop();
        System.out.println("Удаленный элемент: " + removedElement);

        // Выводим содержимое стека после удаления элемента
        System.out.println("Содержимое стека после удаления: " + stack);

        // Получаем элемент с вершины стека без удаления
        int topElement = stack.peek();
        System.out.println("Элемент с вершины стека: " + topElement);

        // Проверяем, пуст ли стек
        System.out.println("Стек пустой? " + stack.empty());

        // Поиск элемента в стеке
        int position = stack.search(20);
        if (position != -1) {
            System.out.println("Позиция элемента 20: " + position);
        } else {
            System.out.println("Элемент 20 не найден в стеке");
        }
    }
}
```

Этот код создает стек целых чисел, добавляет несколько элементов, удаляет элемент с вершины стека, выводит содержимое стека, и так далее.

### 86. Абстрактный тип данных Queue (очередь) в Джава
В Java абстрактный тип данных Queue (очередь) реализуется с помощью интерфейса `java.util.Queue`, который представляет собой коллекцию элементов, работающую по принципу "первый пришел - первый вышел" (First-In, First-Out, FIFO). Это означает, что элементы добавляются в конец очереди (в хвост) и извлекаются из начала очереди (из головы).

Вот основные методы интерфейса `Queue`:

1. `add(E e)` или `offer(E e)`: Добавляет элемент в конец очереди.
2. `remove()` или `poll()`: Удаляет и возвращает элемент из начала очереди.
3. `element()` или `peek()`: Возвращает элемент из начала очереди без его удаления.
4. `isEmpty()`: Проверяет, пуста ли очередь.

Помимо этих основных методов, интерфейс `Queue` также наследует методы от интерфейса `Collection`, что позволяет использовать его вместе с другими методами коллекций.

Пример использования:

```java
import java.util.LinkedList;
import java.util.Queue;

public class Main {
    public static void main(String[] args) {
        Queue<Integer> queue = new LinkedList<>();

        // Добавляем элементы в очередь
        queue.offer(10);
        queue.offer(20);
        queue.offer(30);

        // Выводим содержимое очереди
        System.out.println("Содержимое очереди: " + queue);

        // Удаляем элемент из начала очереди и выводим его
        int removedElement = queue.poll();
        System.out.println("Удаленный элемент: " + removedElement);

        // Выводим содержимое очереди после удаления элемента
        System.out.println("Содержимое очереди после удаления: " + queue);

        // Получаем элемент из начала очереди без удаления
        int headElement = queue.peek();
        System.out.println("Элемент из начала очереди: " + headElement);

        // Проверяем, пуста ли очередь
        System.out.println("Очередь пуста? " + queue.isEmpty());
    }
}
```

Этот код создает очередь целых чисел, добавляет несколько элементов, удаляет элемент из начала очереди, выводит содержимое очереди и т. д.

### 87. Универсальные типы или обобщенные типы данных, для чего создаются? 
Универсальные типы данных, или обобщенные типы данных, в Java создаются для обеспечения безопасности типов и повышения переиспользуемости кода. Они позволяют создавать классы, интерфейсы и методы, которые могут работать с разными типами данных, обеспечивая при этом типовую безопасность.

Основные преимущества использования обобщенных типов данных:

1. **Безопасность типов**: Обобщения позволяют обнаруживать ошибки во время компиляции, связанные с типами данных, что позволяет избежать ошибок времени выполнения, связанных с неправильными преобразованиями типов.

2. **Переиспользуемость кода**: Обобщенные типы данных позволяют создавать универсальные компоненты, которые могут работать с различными типами данных. Это способствует повышению переиспользуемости кода и уменьшению дублирования.

3. **Улучшенная производительность и безопасность**: Использование обобщенных типов данных позволяет избежать необходимости явного приведения типов данных (кастинга) и обеспечивает производительность за счет отсутствия необходимости в динамическом преобразовании типов во время выполнения.

Пример использования обобщенных типов данных:

```java
import java.util.ArrayList;
import java.util.List;

public class Main {
    public static void main(String[] args) {
        // Создание списка целых чисел
        List<Integer> numbers = new ArrayList<>();
        
        // Добавление элементов в список
        numbers.add(10);
        numbers.add(20);
        numbers.add(30);
        
        // Получение элементов списка
        for (Integer number : numbers) {
            System.out.println(number);
        }
    }
}
```

В этом примере `List<Integer>` - это обобщенный тип данных, который создает список, специализированный для работы с целыми числами (`Integer`). Благодаря этому типовому безопасному подходу компилятор обеспечивает, что в список можно добавлять только элементы типа `Integer`, и предотвращает ошибки, связанные с неправильными типами данных.

### 88. Объявление обобщённого класса коллекции с параметризованным методом для обработки массива элементов коллекции на основе цикла for each (определение общего метода для отображения элементов массива)
Вот пример обобщенного класса коллекции с параметризованным методом для обработки массива элементов коллекции с использованием цикла `foreach`:

```java
import java.util.ArrayList;
import java.util.List;

public class GenericCollection<T> {
    private List<T> elements;

    public GenericCollection() {
        elements = new ArrayList<>();
    }

    public void add(T element) {
        elements.add(element);
    }

    // Параметризированный метод для отображения элементов массива коллекции
    public void displayElements() {
        for (T element : elements) {
            System.out.println(element);
        }
    }

    public static void main(String[] args) {
        // Создание экземпляра обобщенного класса с типом String
        GenericCollection<String> stringCollection = new GenericCollection<>();

        // Добавление элементов в коллекцию
        stringCollection.add("One");
        stringCollection.add("Two");
        stringCollection.add("Three");

        // Отображение элементов коллекции
        stringCollection.displayElements();
    }
}
```

В этом примере `GenericCollection<T>` является обобщенным классом с параметром типа `T`. Метод `add` добавляет элемент в коллекцию, а метод `displayElements` использует цикл `foreach` для отображения элементов коллекции.

Параметризованный метод `displayElements` не имеет параметра типа `T`, потому что он использует обобщенный список `elements` класса `GenericCollection`, который уже параметризован типом `T`.

При создании экземпляра обобщенного класса `GenericCollection` с типом `String`, все методы и поля этого класса будут работать с элементами типа `String`.

### 89. Что представляет из себя класс ArrayList и в каком случае используется
Класс `ArrayList` в Java представляет собой динамический массив, который может автоматически изменять свой размер по мере добавления и удаления элементов. Это одна из реализаций интерфейса `List` из Java Collections Framework.

Основные особенности и возможности класса `ArrayList`:

1. **Динамическое изменение размера**: `ArrayList` автоматически увеличивает свой размер при добавлении новых элементов и уменьшает его при удалении элементов.

2. **Быстрый доступ к элементам по индексу**: Элементы в `ArrayList` хранятся в виде массива, поэтому доступ к элементам по индексу выполняется за константное время O(1).

3. **Поддержка обобщенных типов**: `ArrayList` параметризован типом элементов, что обеспечивает типовую безопасность и предотвращает ошибки времени выполнения из-за неправильных типов.

4. **Поддержка всех операций списка**: `ArrayList` реализует интерфейс `List`, поэтому поддерживает все операции списка, такие как добавление, удаление, доступ к элементам, поиск, сортировка и т. д.

`ArrayList` обычно используется в ситуациях, когда требуется хранить и манипулировать последовательностью элементов, и когда требуется быстрый доступ к элементам по индексу. Например, `ArrayList` может быть использован для хранения списка элементов пользовательского ввода, результатов запроса из базы данных, временных данных и т. д.

Пример использования `ArrayList`:

```java
import java.util.ArrayList;

public class Main {
    public static void main(String[] args) {
        // Создание ArrayList для хранения строк
        ArrayList<String> list = new ArrayList<>();

        // Добавление элементов в список
        list.add("Java");
        list.add("Python");
        list.add("C++");

        // Получение и вывод элементов списка
        for (String element : list) {
            System.out.println(element);
        }
    }
}
```

Этот пример создает `ArrayList` для хранения строк, добавляет несколько строк в список и выводит их на экран.

### 90. Обобщенное программирование. Понятие и использование дженериков в Java
Обобщенное программирование в Java позволяет создавать классы, интерфейсы и методы, которые могут работать с различными типами данных. Это достигается с использованием дженериков (generics), которые предоставляют параметризацию типов.

При использовании дженериков вы можете объявить класс или метод с параметром типа, который может быть заменен на конкретный тип данных при создании экземпляра класса или вызове метода. Это обеспечивает типовую безопасность и удобство использования, так как компилятор проверяет типы данных на этапе компиляции.

Основные преимущества использования дженериков в Java:

1. **Безопасность типов**: Дженерики обеспечивают безопасность типов и предотвращают ошибки времени выполнения, связанные с неправильными приведениями типов данных (кастами).

2. **Переиспользуемость кода**: Обобщенные классы и методы позволяют создавать универсальные компоненты, которые могут работать с различными типами данных, повышая переиспользуемость кода.

3. **Уменьшение дублирования кода**: Использование дженериков может уменьшить необходимость создания различных версий классов и методов для работы с разными типами данных.

Пример использования дженериков:

```java
import java.util.ArrayList;
import java.util.List;

public class Main {
    public static void main(String[] args) {
        // Объявление списка строк с использованием дженериков
        List<String> strings = new ArrayList<>();

        // Добавление элементов в список
        strings.add("Java");
        strings.add("Python");
        strings.add("C++");

        // Вывод элементов списка
        for (String str : strings) {
            System.out.println(str);
        }
    }
}
```

В этом примере `List<String>` - это обобщенный тип данных, который определяет, что `strings` является списком строк. Это обеспечивает безопасность типов, и компилятор проверяет, что в список можно добавлять только строки.

### 91. Параметризованные классы и методы. Их определение и использование
Параметризованные классы и методы в Java позволяют создавать универсальные компоненты, которые могут работать с разными типами данных. Это достигается путем определения параметров типа, которые могут быть заменены на конкретные типы данных при создании экземпляров классов или вызове методов.

### Определение параметризованного класса:

```java
public class MyGenericClass<T> {
    private T data;

    public MyGenericClass(T data) {
        this.data = data;
    }

    public T getData() {
        return data;
    }

    public void setData(T data) {
        this.data = data;
    }
}
```

Здесь `T` - это параметр типа, который может быть заменен на любой тип данных при создании экземпляра класса `MyGenericClass`. Например:

```java
MyGenericClass<String> stringObject = new MyGenericClass<>("Hello");
MyGenericClass<Integer> intObject = new MyGenericClass<>(123);
```

### Определение параметризованного метода:

```java
public class MyClass {
    public <T> void printArray(T[] array) {
        for (T element : array) {
            System.out.println(element);
        }
    }
}
```

Здесь `<T>` перед возвращаемым типом метода указывает, что метод является параметризованным и может использовать параметр типа `T`. Например:

```java
MyClass obj = new MyClass();
Integer[] intArray = {1, 2, 3, 4, 5};
String[] strArray = {"a", "b", "c", "d", "e"};
obj.printArray(intArray);
obj.printArray(strArray);
```

В этом примере метод `printArray` вызывается для вывода элементов массива `intArray` и `strArray`. Тип элементов массива определяется при вызове метода.

Параметризованные классы и методы обеспечивают универсальность, переиспользуемость и безопасность типов, что делает код более гибким и читаемым. Они широко используются в различных областях разработки программного обеспечения для работы с различными типами данных.

### 92. Стирание типов.
Стремление к обратной совместимости с предыдущими версиями языка Java привело к введению стирания типов (type erasure) в обобщенные типы данных. Стирание типов означает, что информация о типах параметров обобщенных классов или методов удаляется (стирается) во время компиляции, а не сохраняется во время выполнения программы.

После стирания типов обобщенные типы становятся типами, использующими обычные (непараметризованные) типы данных. Например, если у вас есть обобщенный класс `MyGenericClass<T>`, то после стирания типов он будет выглядеть как `MyGenericClass<Object>`. Таким образом, параметр типа `T` будет заменен на тип `Object`.

Стирание типов выполняется для обеспечения обратной совместимости с более ранними версиями Java, которые не поддерживали обобщения. Однако стирание типов также ограничивает доступ к информации о типах параметров во время выполнения программы.

Например, в следующем обобщенном методе:

```java
public <T> void printList(List<T> list) {
    // ...
}
```

после стирания типов он будет преобразован в метод с обычным списком объектов:

```java
public void printList(List list) {
    // ...
}
```

Информация о типе `T` не будет доступна во время выполнения.

Хотя стирание типов ограничивает некоторые возможности метапрограммирования и рефлексии, оно позволяет сохранить обратную совместимость и облегчает интеграцию обобщенных типов в существующий код.


### 93. Понятие структуры данных список. Линейный список. Виды списков и их реализация на Java. Доступ к элементу структуры данных список. Использование списков. Трудоемкость операций со списками.
Структура данных "список" представляет собой коллекцию элементов, где каждый элемент содержит ссылку на следующий элемент в списке. Одна из наиболее распространенных реализаций списка - линейный список (linked list). 

### Линейный список:
Линейный список представляет собой структуру данных, где каждый элемент (узел) состоит из двух частей: значения и ссылки на следующий элемент. Первый элемент списка называется головой (head), а последний - хвостом (tail), который имеет ссылку на null.

### Виды списков и их реализация на Java:
В Java список может быть реализован разными способами, включая LinkedList, ArrayList и другие пользовательские реализации. Вот некоторые типы списков и их краткое описание:

1. **LinkedList**: Это реализация линейного списка в Java. Каждый элемент содержит ссылку на следующий элемент. Эта реализация позволяет эффективно добавлять и удалять элементы в начале, середине и конце списка.

2. **ArrayList**: Это динамический массив, который также может рассматриваться как список. Он предоставляет быстрый доступ к элементам по индексу, но менее эффективен при вставке и удалении элементов в середине списка.

3. **Другие пользовательские реализации**: Вы можете также создавать собственные реализации списков, такие как двусвязный список (doubly linked list), кольцевой список (circular linked list) и т. д., в зависимости от требований вашего приложения.

### Доступ к элементу структуры данных список:
В линейном списке доступ к элементу осуществляется путем итерации по списку, начиная с головы (head) и двигаясь к следующим элементам с помощью ссылок.

### Использование списков:
Списки широко используются в программировании для хранения и управления коллекциями данных. Они могут быть использованы для реализации различных алгоритмов, включая очереди, стеки, алгоритмы поиска, сортировки и т. д.

### Трудоемкость операций со списками:
Трудоемкость операций со списками зависит от конкретной реализации списка. В общем случае:

- **Добавление или удаление элемента в начале списка**: O(1) для LinkedList, O(n) для ArrayList (из-за необходимости перемещения элементов при изменении размера массива).
  
- **Добавление или удаление элемента в конце списка**: O(1) для LinkedList (при наличии ссылки на хвост), O(n) для ArrayList (при изменении размера массива).

- **Добавление или удаление элемента в середине списка**: O(n) для LinkedList (из-за необходимости перемещения к нужной позиции), O(n) для ArrayList (при изменении размера массива и перемещении элементов).

- **Доступ к элементу по индексу**: O(n) для LinkedList (требуется проход по списку до нужного элемента), O(1) для ArrayList (так как доступ к элементу осуществляется напрямую по индексу).

Выбор конкретной реализации списка зависит от требований вашего приложения к скорости доступа, вставки, удаления элементов и использования памяти.

### 94. Односвязный и двусвязный список. Способы реализации на языке Джава
Односвязный список (Singly Linked List) и двусвязный список (Doubly Linked List) являются двумя различными реализациями линейного списка.

### Односвязный список:
Односвязный список состоит из узлов, каждый из которых содержит два поля: данные и ссылку на следующий узел в списке. Последний узел списка имеет ссылку на null.

#### Реализация в Java:
```java
class ListNode {
    int data;
    ListNode next;

    public ListNode(int data) {
        this.data = data;
        this.next = null;
    }
}

public class SinglyLinkedList {
    private ListNode head;

    public SinglyLinkedList() {
        this.head = null;
    }

    // Методы для добавления, удаления и доступа к элементам
}
```

### Двусвязный список:
Двусвязный список также состоит из узлов, но каждый узел содержит две ссылки: на предыдущий и следующий узел. Последний узел списка имеет ссылку на null как для предыдущего, так и для следующего узла.

#### Реализация в Java:
```java
class ListNode {
    int data;
    ListNode prev;
    ListNode next;

    public ListNode(int data) {
        this.data = data;
        this.prev = null;
        this.next = null;
    }
}

public class DoublyLinkedList {
    private ListNode head;

    public DoublyLinkedList() {
        this.head = null;
    }

    // Методы для добавления, удаления и доступа к элементам
}
```

Оба типа списков могут использоваться для различных задач, и выбор между ними зависит от требований к конкретному приложению. Односвязный список обычно более прост в реализации и требует меньше памяти, но он менее эффективен при некоторых операциях, таких как обратный доступ к элементам. Двусвязный список обеспечивает более эффективный обратный доступ к элементам, но требует больше памяти и сложнее в реализации.

### 95. Возможости Java Framework Collection. Контейнер ArrayList и его основные методы.
Java Collections Framework (JCF) предоставляет набор классов и интерфейсов для работы с коллекциями объектов. Одним из наиболее популярных классов коллекций является `ArrayList`.

#### Возможности Java Collections Framework:
1. **Интерфейсы коллекций**: Фреймворк включает в себя интерфейсы для представления различных типов коллекций, таких как списки (`List`), множества (`Set`), карты (`Map`) и др.
  
2. **Реализации коллекций**: Фреймворк также предоставляет реализации различных коллекций, включая `ArrayList`, `LinkedList`, `HashSet`, `HashMap` и т. д.

3. **Алгоритмы**: JCF включает в себя алгоритмы для сортировки, поиска, манипулирования и т. д. коллекциями.

#### Контейнер ArrayList и его основные методы:
`ArrayList` представляет собой динамический массив, который может увеличивать свой размер по мере добавления элементов. Основные методы `ArrayList` включают:

1. **add(E element)**: Добавляет элемент в конец списка.
2. **add(int index, E element)**: Вставляет элемент по указанному индексу.
3. **get(int index)**: Возвращает элемент по указанному индексу.
4. **set(int index, E element)**: Заменяет элемент в указанной позиции.
5. **remove(int index)**: Удаляет элемент по указанному индексу.
6. **size()**: Возвращает размер списка.
7. **isEmpty()**: Проверяет, пуст ли список.
8. **clear()**: Удаляет все элементы из списка.
9. **contains(Object o)**: Проверяет, содержится ли элемент в списке.
10. **indexOf(Object o)**: Возвращает индекс первого вхождения элемента в список.
11. **lastIndexOf(Object o)**: Возвращает индекс последнего вхождения элемента в список.

Пример использования `ArrayList`:
```java
import java.util.ArrayList;

public class Main {
    public static void main(String[] args) {
        ArrayList<String> list = new ArrayList<>();
        list.add("apple");
        list.add("banana");
        list.add("orange");

        System.out.println(list); // Выводит: [apple, banana, orange]
        System.out.println(list.get(1)); // Выводит: banana
        list.remove(0);
        System.out.println(list); // Выводит: [banana, orange]
    }
}
```

Это лишь некоторые из методов `ArrayList`. Они предоставляют удобные средства для управления списками объектов в Java.

### 96. Возможости Java Framework Collection. Контейнер LinkedList и его основные методы.
Java Collections Framework (JCF) предоставляет набор классов и интерфейсов для работы с коллекциями объектов. Одним из таких классов является `LinkedList`.

#### Контейнер LinkedList и его основные методы:
`LinkedList` представляет собой структуру данных, основанную на узлах, каждый из которых содержит ссылку на следующий и/или предыдущий узел. Основные методы `LinkedList` включают:

1. **add(E element)**: Добавляет элемент в конец списка.
2. **add(int index, E element)**: Вставляет элемент по указанному индексу.
3. **get(int index)**: Возвращает элемент по указанному индексу.
4. **set(int index, E element)**: Заменяет элемент в указанной позиции.
5. **remove(int index)**: Удаляет элемент по указанному индексу.
6. **size()**: Возвращает размер списка.
7. **isEmpty()**: Проверяет, пуст ли список.
8. **clear()**: Удаляет все элементы из списка.
9. **contains(Object o)**: Проверяет, содержится ли элемент в списке.
10. **indexOf(Object o)**: Возвращает индекс первого вхождения элемента в список.
11. **lastIndexOf(Object o)**: Возвращает индекс последнего вхождения элемента в список.

Пример использования `LinkedList`:
```java
import java.util.LinkedList;

public class Main {
    public static void main(String[] args) {
        LinkedList<String> list = new LinkedList<>();
        list.add("apple");
        list.add("banana");
        list.add("orange");

        System.out.println(list); // Выводит: [apple, banana, orange]
        System.out.println(list.get(1)); // Выводит: banana
        list.remove(0);
        System.out.println(list); // Выводит: [banana, orange]
    }
}
```

Это лишь некоторые из методов `LinkedList`. Они предоставляют удобные средства для управления списками объектов в Java. Основное отличие `LinkedList` от `ArrayList` заключается в том, что `LinkedList` представляет собой **двунаправленный список**, что обеспечивает более эффективные операции вставки и удаления элементов в середине списка, но менее эффективный **доступ** к элементам по индексу.

### 97. Возможости Java Framework Collection. Интерфейс Map и его основные методы.
Java Collections Framework (JCF) предоставляет набор классов и интерфейсов для работы с коллекциями объектов. Один из основных интерфейсов, предоставляемых JCF, это интерфейс `Map`, который представляет отображение (ассоциативный массив) ключей на значения.

#### Интерфейс Map и его основные методы:
Интерфейс `Map` представляет собой коллекцию объектов, где каждый объект ассоциируется с уникальным ключом. Основные методы `Map` включают:

1. **put(K key, V value)**: Добавляет в отображение значение `value`, связанное с ключом `key`.
2. **get(Object key)**: Возвращает значение, связанное с указанным ключом, или null, если ключ не найден.
3. **remove(Object key)**: Удаляет значение, связанное с указанным ключом, и возвращает его, или null, если ключ не найден.
4. **containsKey(Object key)**: Проверяет, содержится ли указанный ключ в отображении.
5. **containsValue(Object value)**: Проверяет, содержится ли указанное значение в отображении.
6. **keySet()**: Возвращает набор всех ключей в отображении.
7. **values()**: Возвращает коллекцию всех значений в отображении.
8. **entrySet()**: Возвращает набор записей (ключ-значение) в отображении.

Пример использования `Map`:
```java
import java.util.HashMap;
import java.util.Map;

public class Main {
    public static void main(String[] args) {
        Map<String, Integer> map = new HashMap<>();
        map.put("apple", 10);
        map.put("banana", 20);
        map.put("orange", 30);

        System.out.println(map.get("banana")); // Выводит: 20
        System.out.println(map.containsKey("apple")); // Выводит: true
        System.out.println(map.containsValue(30)); // Выводит: true
        map.remove("orange");
        System.out.println(map); // Выводит: {apple=10, banana=20}
    }
}
```

Это лишь некоторые из методов `Map`. Интерфейс `Map` предоставляет мощные средства для хранения и управления парами ключ-значение в Java.

### 98. Возможости Java Framework Collection. Контейнер HashMap и его основные методы.
Java Collections Framework (JCF) предоставляет набор классов и интерфейсов для работы с коллекциями объектов. Одним из ключевых классов коллекций является `HashMap`.

#### Контейнер HashMap и его основные методы:
`HashMap` представляет собой реализацию интерфейса `Map`, которая использует хеш-таблицу для хранения пар ключ-значение. Основные методы `HashMap` включают:

1. **put(K key, V value)**: Добавляет в отображение значение `value`, связанное с ключом `key`.
2. **get(Object key)**: Возвращает значение, связанное с указанным ключом, или null, если ключ не найден.
3. **remove(Object key)**: Удаляет значение, связанное с указанным ключом, и возвращает его, или null, если ключ не найден.
4. **containsKey(Object key)**: Проверяет, содержится ли указанный ключ в отображении.
5. **containsValue(Object value)**: Проверяет, содержится ли указанное значение в отображении.
6. **keySet()**: Возвращает набор всех ключей в отображении.
7. **values()**: Возвращает коллекцию всех значений в отображении.
8. **entrySet()**: Возвращает набор записей (ключ-значение) в отображении.

Пример использования `HashMap`:
```java
import java.util.HashMap;
import java.util.Map;

public class Main {
    public static void main(String[] args) {
        Map<String, Integer> map = new HashMap<>();
        map.put("apple", 10);
        map.put("banana", 20);
        map.put("orange", 30);

        System.out.println(map.get("banana")); // Выводит: 20
        System.out.println(map.containsKey("apple")); // Выводит: true
        System.out.println(map.containsValue(30)); // Выводит: true
        map.remove("orange");
        System.out.println(map); // Выводит: {apple=10, banana=20}
    }
}
```

`HashMap` обеспечивает высокую скорость доступа к данным благодаря использованию хеш-таблицы для хранения пар ключ-значение. Он является одной из самых распространенных и эффективных реализаций карты в Java.

### 99. Коллекция HashMap, принципы создания и методы работы с ней
`HashMap` в Java представляет собой структуру данных, реализующую интерфейс `Map`, которая использует хеш-таблицу для хранения пар ключ-значение. Она обеспечивает быстрый доступ к элементам благодаря использованию хеш-таблицы. Вот основные принципы создания и методы работы с `HashMap`:

### Создание HashMap:
Чтобы создать экземпляр `HashMap`, используйте конструктор класса `HashMap`:

```java
HashMap<KeyType, ValueType> map = new HashMap<>();
```

### Основные методы работы с HashMap:

1. **put(KeyType key, ValueType value)**: Добавляет пару ключ-значение в `HashMap`.

    ```java
    map.put("key", "value");
    ```

2. **get(Object key)**: Возвращает значение, связанное с указанным ключом.

    ```java
    ValueType value = map.get("key");
    ```

3. **remove(Object key)**: Удаляет запись с указанным ключом из `HashMap`.

    ```java
    map.remove("key");
    ```

4. **containsKey(Object key)**: Проверяет, содержит ли `HashMap` ключ.

    ```java
    boolean containsKey = map.containsKey("key");
    ```

5. **containsValue(Object value)**: Проверяет, содержит ли `HashMap` значение.

    ```java
    boolean containsValue = map.containsValue("value");
    ```

6. **keySet()**: Возвращает набор всех ключей в `HashMap`.

    ```java
    Set<KeyType> keySet = map.keySet();
    ```

7. **values()**: Возвращает коллекцию всех значений в `HashMap`.

    ```java
    Collection<ValueType> values = map.values();
    ```

8. **entrySet()**: Возвращает набор записей (ключ-значение) в `HashMap`.

    ```java
    Set<Map.Entry<KeyType, ValueType>> entrySet = map.entrySet();
    ```

### Пример использования HashMap:

```java
import java.util.HashMap;
import java.util.Map;

public class Main {
    public static void main(String[] args) {
        HashMap<String, Integer> map = new HashMap<>();

        map.put("apple", 10);
        map.put("banana", 20);
        map.put("orange", 30);

        System.out.println("Value for key 'apple': " + map.get("apple"));
        System.out.println("Contains key 'banana': " + map.containsKey("banana"));

        map.remove("orange");

        System.out.println("Key set: " + map.keySet());
        System.out.println("Values: " + map.values());
        System.out.println("Entries: " + map.entrySet());
    }
}
```

Это основные методы работы с `HashMap`. Они обеспечивают эффективное управление парами ключ-значение в `HashMap`.

### 100. Использование обобщенного класса HashMap, которая реализует интерфейс Map для хранения пар ключ-значение в разработке программ. 
Вот пример использования обобщенного класса `HashMap` для хранения пар ключ-значение в разработке программы:

```java
import java.util.HashMap;
import java.util.Map;

public class Main {
    public static void main(String[] args) {
        // Создание объекта HashMap для хранения строковых ключей и целочисленных значений
        Map<String, Integer> map = new HashMap<>();

        // Добавление пар ключ-значение в HashMap
        map.put("apple", 10);
        map.put("banana", 20);
        map.put("orange", 30);

        // Вывод значений по ключам
        System.out.println("Value for key 'apple': " + map.get("apple"));
        System.out.println("Value for key 'banana': " + map.get("banana"));
        System.out.println("Value for key 'orange': " + map.get("orange"));

        // Проверка наличия ключа в HashMap
        System.out.println("Contains key 'apple': " + map.containsKey("apple"));
        System.out.println("Contains key 'grape': " + map.containsKey("grape"));

        // Удаление элемента из HashMap
        map.remove("banana");

        // Вывод всех ключей, значений и записей
        System.out.println("Keys: " + map.keySet());
        System.out.println("Values: " + map.values());
        System.out.println("Entries: " + map.entrySet());
    }
}
```

Этот пример демонстрирует создание объекта `HashMap`, добавление пар ключ-значение, получение значений по ключам, проверку наличия ключей, удаление элемента и вывод всех ключей, значений и записей в `HashMap`. Обобщенный класс `HashMap` позволяет безопасно хранить пары ключ-значение различных типов данных.

### 101. Возможости Java Framework Collection. Контейнер HashSet и его основные методы.
`HashSet` в Java представляет собой реализацию интерфейса `Set`, которая использует хеш-таблицу для хранения уникальных элементов. Вот основные методы работы с `HashSet`:

1. **add(E e)**: Добавляет элемент в `HashSet`, если он еще не присутствует.
   
   ```java
   HashSet<String> set = new HashSet<>();
   set.add("apple");
   ```

2. **remove(Object o)**: Удаляет указанный элемент из `HashSet`, если он присутствует.
   
   ```java
   set.remove("apple");
   ```

3. **contains(Object o)**: Проверяет, содержится ли указанный элемент в `HashSet`.
   
   ```java
   boolean contains = set.contains("apple");
   ```

4. **size()**: Возвращает количество элементов в `HashSet`.

   ```java
   int size = set.size();
   ```

5. **isEmpty()**: Проверяет, пуст ли `HashSet`.
   
   ```java
   boolean isEmpty = set.isEmpty();
   ```

6. **clear()**: Удаляет все элементы из `HashSet`.
   
   ```java
   set.clear();
   ```

7. **iterator()**: Возвращает итератор для обхода элементов в `HashSet`.

   ```java
   Iterator<String> iterator = set.iterator();
   while (iterator.hasNext()) {
       System.out.println(iterator.next());
   }
   ```

8. **addAll(Collection<? extends E> c)**: Добавляет все элементы из указанной коллекции в `HashSet`.
   
   ```java
   List<String> list = new ArrayList<>();
   list.add("apple");
   list.add("banana");
   set.addAll(list);
   ```

Это основные методы работы с `HashSet`. Он предоставляет быстрый доступ к элементам и гарантирует уникальность элементов в коллекции.

### 102. Обобщенный класс HashSet класс коллекция, наследует свой функционал от класса AbstractSet, а также реализует интерфейс Set. Что он себя представляет? 
`AbstractSet` - это абстрактный класс в Java, который предоставляет базовую реализацию интерфейса `Set`. Он является частью Java Collections Framework и предназначен для облегчения создания пользовательских классов множеств.

`AbstractSet` реализует большую часть функциональности, необходимой для создания классов, представляющих различные реализации множеств. Он обрабатывает общие случаи для методов интерфейса `Set`, таких как `add`, `remove`, `contains` и другие.

Поскольку `AbstractSet` является абстрактным классом, он сам по себе не предоставляет реализации для всех методов интерфейса `Set`, а лишь определяет методы, которые должны быть реализованы в классах-потомках. Таким образом, пользовательские классы множеств могут наследоваться от `AbstractSet` и реализовывать только те методы, которые отличаются от общих реализаций. Это сокращает объем кода и облегчает создание новых классов множеств.

`Set` в Java представляет собой интерфейс, который представляет собой коллекцию элементов без дубликатов. Каждый элемент может встречаться в наборе не более одного раза. Основные особенности `Set` включают:

1. **Уникальность элементов**: В `Set` не может быть дублирующихся элементов. Если вы попытаетесь добавить элемент, который уже присутствует в множестве, операция добавления будет проигнорирована.

2. **Быстрый поиск элементов**: Реализации интерфейса `Set` обычно используют оптимизированные структуры данных для обеспечения эффективного поиска элементов.

3. **Нет гарантированного порядка элементов**: Порядок элементов в `Set` зависит от конкретной реализации. Например, `HashSet` не гарантирует порядок элементов, в то время как `TreeSet` предоставляет упорядоченное множество в соответствии с компаратором или естественным порядком элементов.

4. **Отсутствие индексации элементов**: Элементы в `Set` не имеют индексов, поэтому вы не можете получить доступ к элементу по индексу, как в случае с `List`.

5. **Интерфейс операций множества**: `Set` предоставляет методы для выполнения стандартных операций множества, таких как добавление элемента, удаление элемента, проверка наличия элемента и т. д.

Примеры реализаций `Set` включают `HashSet`, `TreeSet` и `LinkedHashSet`. Каждая из этих реализаций обладает своими особенностями в отношении производительности, упорядоченности элементов и т. д.

### 103. Регулярные выражения и организация работы с ними в Java. Примеры
Регулярные выражения (регэкспы) - это шаблоны, используемые для сопоставления и поиска строк в тексте. В Java работа с регулярными выражениями осуществляется через пакет `java.util.regex`. Вот примеры организации работы с регулярными выражениями в Java:

### 1. Проверка на соответствие регулярному выражению:
```java
import java.util.regex.Pattern;
import java.util.regex.Matcher;

public class Main {
    public static void main(String[] args) {
        String text = "The quick brown fox jumps over the lazy dog";
        String regex = "fox";
        Pattern pattern = Pattern.compile(regex);
        Matcher matcher = pattern.matcher(text);
        
        if (matcher.find()) {
            System.out.println("Строка содержит подстроку 'fox'.");
        } else {
            System.out.println("Строка не содержит подстроку 'fox'.");
        }
    }
}
```

### 2. Поиск всех вхождений подстрок, соответствующих регулярному выражению:
```java
import java.util.regex.Pattern;
import java.util.regex.Matcher;

public class Main {
    public static void main(String[] args) {
        String text = "The quick brown fox jumps over the lazy dog";
        String regex = "\\b\\w{3}\\b"; // Найти все слова из трех букв
        Pattern pattern = Pattern.compile(regex);
        Matcher matcher = pattern.matcher(text);
        
        while (matcher.find()) {
            System.out.println("Найдено совпадение: " + matcher.group());
        }
    }
}
```

### 3. Замена всех вхождений подстрок, соответствующих регулярному выражению:
```java
public class Main {
    public static void main(String[] args) {
        String text = "The quick brown fox jumps over the lazy dog";
        String regex = "\\bfox\\b";
        String replacement = "cat";
        String result = text.replaceAll(regex, replacement);
        
        System.out.println("Исходный текст: " + text);
        System.out.println("Текст после замены: " + result);
    }
}
```

### 4. Разделение строки на подстроки с помощью регулярного выражения:
```java
public class Main {
    public static void main(String[] args) {
        String text = "The quick brown fox jumps over the lazy dog";
        String regex = "\\s+"; // Разделитель - один или несколько пробелов
        String[] parts = text.split(regex);
        
        System.out.println("Разделенные слова:");
        for (String part : parts) {
            System.out.println(part);
        }
    }
}
```

Это лишь некоторые примеры использования регулярных выражений в Java. Регулярные выражения позволяют проводить сложные операции по обработке текста, такие как поиск, замена, разделение и многое другое.

### 104. Структура коллекций в Java Collection Framework. Иерархия интефейсов 
Java Collections Framework (JCF) предоставляет набор интерфейсов и классов для работы с коллекциями объектов. Вот основные интерфейсы, составляющие иерархию в Java Collections Framework:

1. **`Collection`**: Это корневой интерфейс, который представляет общий функционал для всех коллекций. Он определяет базовые операции, такие как добавление, удаление и проверка наличия элементов.

    - **`List`**: Подинтерфейс `Collection`, который представляет упорядоченную коллекцию, допускающую дублирование элементов. Основные реализации включают `ArrayList`, `LinkedList` и `Vector`.
    
    - **`Set`**: Подинтерфейс `Collection`, который представляет коллекцию, не допускающую дублирование элементов. Основные реализации включают `HashSet`, `TreeSet` и `LinkedHashSet`.
    
    - **`Queue`**: Подинтерфейс `Collection`, который представляет коллекцию, обеспечивающую специфический порядок обработки элементов. Основные реализации включают `PriorityQueue` и `ArrayDeque`.
    
    - **`Deque`**: Подинтерфейс `Queue`, который представляет двустороннюю очередь. Основные реализации включают `ArrayDeque`.
    
2. **`Map`**: Этот интерфейс представляет собой отображение (mapping) ключей на значения. Каждый ключ в отображении должен быть уникальным. Основные реализации включают `HashMap`, `TreeMap`, `LinkedHashMap` и `Hashtable`.

Эти интерфейсы и классы образуют основу Java Collections Framework, предоставляя различные способы хранения, доступа и управления коллекциями объектов в Java.

### 105. Одним из ключевых методов интерфейса Collection является метод Iterator<E> iterator(). Что возвращает это метод?
Метод `iterator()` интерфейса `Collection` возвращает объект типа `Iterator<E>`. 

Интерфейс `Iterator<E>` представляет собой механизм для обхода элементов в коллекции поочередно. Он позволяет последовательно получать элементы коллекции, начиная с первого и заканчивая последним. 

С помощью метода `iterator()` можно получить итератор для конкретной коллекции и использовать его для обхода элементов. Каждый вызов метода `iterator()` возвращает новый итератор, начинающий обход коллекции с самого начала.

Итератор (Iterator) в Java - это объект, который предоставляет способ последовательного перебора элементов в коллекции. Он предоставляет методы для проверки наличия следующего элемента, получения следующего элемента и удаления текущего элемента (не во всех коллекциях). Итераторы очень полезны при обходе коллекций, так как они позволяют получить доступ к каждому элементу поочередно без необходимости знать внутреннюю структуру коллекции.

Вот основные методы интерфейса `Iterator`:

1. **`boolean hasNext()`**: Возвращает `true`, если итератор имеет следующий элемент, и `false`, если достигнут конец коллекции.

2. **`E next()`**: Возвращает следующий элемент в коллекции. Если достигнут конец коллекции или вызван после последнего элемента, возникает исключение `NoSuchElementException`.

3. **`void remove()`**: Удаляет текущий элемент из коллекции (необязательная операция). Если метод `remove()` вызывается перед вызовом метода `next()`, или после вызова метода `remove()` один раз за предыдущий вызов метода `next()`, это вызовет исключение `IllegalStateException`.

Итераторы предоставляют универсальный способ обхода коллекций в Java, что делает их очень мощным инструментом для работы с данными. Они используются во многих классах и методах стандартной библиотеки Java, а также могут быть использованы для создания собственных алгоритмов обработки данных.
